### SELECT 문
```SQL
select field from table [where ] [group by ] [having ] [order by ];
```
- having은 group by절이 사용될 때만 사용 가능
- order by절은 항상 가장 나중에 사용
- where 조건
- field 작성 시 as를 이용해 별칭 설정 가능
- 숫자 데이터일 때 더하여 표시 가능 `field + 500` -> 500이 더해져 출력됨
- 중복 데이터 제외 distinct 사용
  `SELECT DISTINCT purchase_customer FROM purchase;`
- 중복 데이터 제외 시 2가지 이상의 필드가 들어갈 때 모든 필드가 중복되어야 제거됨
- order by 정렬 ASC(오름차순) DESC(내림차순)
  오름차순
  `SELECT DISTINCT purchase_qnty FROM purchase ORDER BY purchase_qnty [ASC];` ASC는 기본값이기 때문에 쓰지 않아도 됨
  내림차순
  `SELECT DISTINCT purchase_qnty FROM purchase ORDER BY purchase_qnty DESC;
- 리미트
  4번째부터 7번째 까지 데이터 출력
  `SELECT * FROM TABLE limit 3,4;`
- 오프셋
  3개의 레코드 이동하고 4번째부터 출력
  `SELECT * FROM TABLE limit 4 offset 3;`
- 그룹별 표시 group by
  `SELECT * FROM TABLE GROUP BY FIELD_NAME;`
- 그룹별 표시에 조건 설정 having
  `SELECT * FROM TABLE GROUP BY FIELD_NAME HAVING FIELD_NAME > 10;`
### UPDATE 문
```SQL
UPDATE TABLE_NAME SET 컬럼이름=값 WHERE 조건;
```
### DELETE 문
```SQL
DELETE FROM TABLE_NAME WHERE 조건;
```
- 조건 없으면 테이블 내 모든 데이터가 삭제됨
### JOIN
2개 테이블에서 레코드 추출
```SQL
SELECT 컬럼이름1 FROM 테이블이름1 UNION SELECT 컬럼이름2 FROM 테이블이름2;
```
- 자료형이 달라도 추출할 수 있는 데이터는 모두 추출함
- 속성 수가 같아야 함
- UNION 을 여러번 씀으로 3개 이상의 테이블을 합칠 수 잇음
- 기본적으로 UNION은 중복 데이터를 제거한다
- 중복 허용하는 법 ALL 사용
```SQL
SELECT 컬럼이름1 FROM 테이블이름1 UNION ALL SELECT 컬럼이름2 FROM 테이블이름2;
```
- 내부 결합
```SQL
SELECT 컬럼이름 FROM 테이블 JOIN 결합할테이블 ON 테이블1_컬럼 = 테이블2_컬럼;
-- 아래와 같이 사용할 수도 있다
SELECT 컬럼이름 FROM 테이블1,테이블2 WHERE 조건;
```
### 외래 키 (FOREIGN KEY)
상호 관련이 있는 테이블들 사이에서 데이터의 일관성을 보장해 주는 수단
```SQL
ALTER TABLE 테이블이름 ADD [CONSTRAINT 제약조건이름] FOREIGN KEY(필드이름) REFERENCES 테이블이름(필드이름);
```
### CHECK 제약 조건
테이블의 특정 속성에 입력되는 값들을 좀더 엄격하게 값이 올바른지를 검사하기 위해 특정 속성에 대한 제약조건을 지정
```SQL
ALTER TABLE 테이블이름 MODIFY 컬럼이름 컬럼자료형 CHECK(조건);
```
### 사용자 생성 및 권한 부여
- 사용자 생성
```SQL
CREATE USER 사용자명@'호스트' IDENTIFIED BY '비밀번호';
```
- 권한 부여
```SQL
-- 모든 권한 부여
GRANT ALL PRIVILEGES ON 데이터베이스명.* TO 사용자명;
-- 특정 권한 부여
GRANT 부여할 SQL 명령문 권한 ON 데이터베이스명.* TO 사용자명;
```
- 생성과 동시에 권한 부여
```SQL
GRANT ALL PRIVILEGES ON 데이터베이스이름.* TO 사용자명@'호스트' IDENTIFIED BY '비밀번호' WITH GRANT OPTION;
```
- 사용자 삭제
```SQL
DROP USER '사용자명';
```
- 권한 회수
```SQL
REVOKE SQL명령문 ON 데이터베이스명.* FROM '사용자명';
```
- 비밀번호 변경
```SQL
SET PASSWORD FOR 사용자명@'호스트'=PASSWORD('비밀번호');
-- 아래와 같이 작성할 수도 있다.
ALTER USER 사용자명@'호스트' IDENTIFIED BY '비밀번호';
```
### 뷰
SELECT 한 결과를 담고 있는 가상 테이블
데이터를 실제로 저장하지 않고 논리적으로만 존재하는 테이블
```SQL
CREATE VIEW 뷰이름[(속성리스트)] AS SELECT... [WITH CHECK OPTION]
```

EX)
```SQL
create view v_vip02 
as selectcustomer_id,customer_name,customer_age,customer_grade
from customerD
where customer_grade = 'vip';
```
### 저장 프로시저
여러 SQL 문을 일괄 처리하기 위한 기능으로서, 이런 저장 프로시저를 작성하여 데이터베이스의 개체로 저장해 두었다가 응용 프로그램에서 call 문으로 호출하여 사용
```SQL
CREATE PROCEDURE 저장프로시저이름()
BEGIN
	SQL...;
	SQL...;
END
```
### 트랜잭션
하나의 작업을 수행하는데 필요한 데이터베이스 연산들을 모아놓은 것
실행 시 COMMIT을 실행할 때 까지 COMMIT이 실행되지 않음

---
## 데이터베이스 시스템 정의
- **데이터베이스 시스템(DBS)**: 데이터를 저장하고 관리하여 조직에 필요한 정보를 생성.
- 구성 요소: 데이터베이스, DBMS, 사용자, 데이터 언어, 컴퓨터 하드웨어.
## 데이터베이스 구조
### 스키마와 인스턴스
- **스키마(schema)**: 데이터베이스 구조와 제약조건 정의.
- **인스턴스(instance)**: 스키마에 따라 실제 저장된 데이터.
### 3단계 데이터베이스 구조 (ANSI/SPARC)
1. **외부 단계**: 개별 사용자의 관점 (외부 스키마).
2. **개념 단계**: 조직 전체의 관점 (개념 스키마).
3. **내부 단계**: 물리적 저장 장치 관점 (내부 스키마).
### 데이터 독립성
- **논리적 데이터 독립성**: 개념 스키마 변경 시 외부 스키마에 영향 없음.
- **물리적 데이터 독립성**: 내부 스키마 변경 시 개념 스키마에 영향 없음.
### 데이터 사전 및 디렉터리
- **데이터 사전**: 메타 데이터 관리.
- **데이터 디렉터리**: 데이터 위치 정보 관리.
## 데이터베이스 사용자
1. **DBA**: 데이터베이스 관리자, 시스템 운영 및 관리.
2. **최종 사용자**: 데이터를 조작하는 사용자.
3. **응용 프로그래머**: 데이터 언어로 프로그램 작성.
## 데이터 언어
1. **DDL (데이터 정의어)**: 스키마 정의/수정/삭제.
2. **DML (데이터 조작어)**: 데이터 삽입/삭제/수정/검색.
   - **절차적 DML**: 처리 과정 명시.
   - **비절차적 DML**: 필요한 데이터만 명시.
3. **DCL (데이터 제어어)**: 무결성, 보안, 회복, 동시성 제어.
## 데이터베이스 관리 시스템(DBMS) 구성
- **질의 처리기**: 사용자 요청 해석 및 처리.
- **저장 데이터 관리자**: 데이터베이스와 데이터 사전 관리.

---
## 데이터 모델링과 데이터 모델
### 데이터 모델링 (Data Modeling)
- 현실 세계 데이터를 컴퓨터 세계의 데이터베이스로 변환하는 과정.
- **2단계 데이터 모델링**:
  1. **개념적 데이터 모델링**: 현실 데이터를 추출하여 개념화.
  2. **논리적 데이터 모델링**: 개념적 구조를 데이터베이스 저장 구조로 표현.
### 데이터 모델
- 데이터를 데이터베이스 구조로 표현하는 도구.
  - **개념적 데이터 모델**: 사람이 이해할 수 있는 수준에서 데이터 구조 표현.
    - 예: 개체-관계 모델 (E-R Model).
  - **논리적 데이터 모델**: 개념적 구조를 컴퓨터가 처리할 수 있는 논리적 구조로 변환.
    - 예: 관계 데이터 모델.

---
## 개체-관계 모델 (E-R Model)
- 현실 세계를 개념적 구조로 표현하는 모델.
- **핵심 요소**: 개체(Entity), 속성(Attribute), 관계(Relationship).
### 개체
- 데이터베이스에 저장할 가치가 있는 사람, 사물, 개념, 사건.
- **표현**: 사각형.
- **속성**: 개체의 고유 특성, 타원으로 표현.
  - 단일 값 / 다중 값, 단순 / 복합, 유도, 널 속성.
- **키 속성**: 개체 인스턴스 식별, 밑줄로 표현.
### 관계
- 개체 간 연관성.
- **관계 유형**:
  1. 일대일 (1:1)
  2. 일대다 (1:n)
  3. 다대다 (n:m)
- **관계의 종속성**:
  - 약한 개체: 강한 개체에 의존, 이중 사각형과 이중 마름모로 표현.

---
## 논리적 데이터 모델
- **개념적 모델**을 컴퓨터 환경에 맞게 변환.
- 데이터베이스 스키마로 표현.
### 관계 데이터 모델
- 데이터 구조를 2차원 테이블 형태로 표현.
- **특징**: 구조 간단, 데이터 간 관계 정의 용이.
### 계층 데이터 모델
- 트리 형태의 논리적 구조.
- **특징**: 상하 관계 표현, 다대다 관계 표현 어려움.
### 네트워크 데이터 모델
- 그래프 형태의 논리적 구조.
- **특징**: 복잡한 구조, 다대다 관계 표현 어려움.

---
## 관계 데이터 모델의 개념
### 기본 용어
- **릴레이션 (Relation)**: 개체 데이터를 2차원 테이블 구조로 저장.
- **속성 (Attribute)**: 릴레이션의 열, 데이터의 구체적 정보 항목.
- **투플 (Tuple)**: 릴레이션의 행, 데이터 레코드.
- **도메인 (Domain)**: 속성이 가질 수 있는 모든 값의 집합.
- **널 (Null)**: 값이 없거나 모르는 상태.
- **차수 (Degree)**: 릴레이션의 속성 개수.
- **카디널리티 (Cardinality)**: 릴레이션의 투플 개수.
### 릴레이션 구성
- **릴레이션 스키마**: 릴레이션의 논리적 구조, 속성 정의.
- **릴레이션 인스턴스**: 특정 시점의 투플 집합.
- **데이터베이스 스키마**: 모든 릴레이션 스키마의 집합.
- **데이터베이스 인스턴스**: 모든 릴레이션 인스턴스의 집합.
### 릴레이션 특성
1. **투플의 유일성**: 동일한 투플 존재 불가.
2. **투플의 무순서**: 투플 간 순서 무의미.
3. **속성의 무순서**: 속성 간 순서 무의미.
4. **속성의 원자성**: 속성 값은 원자 값만 가능.
---
## 키 (Key)
- 릴레이션에서 투플을 유일하게 구별하는 속성 또는 속성 집합.
### 키의 특성
1. **유일성**: 각 투플은 서로 다른 키 값을 가짐.
2. **최소성**: 꼭 필요한 최소한의 속성들로만 구성.
### 키의 종류
1. **슈퍼키**: 유일성을 만족하는 속성 집합.
2. **후보키**: 유일성과 최소성을 만족하는 속성 집합.
3. **기본키**: 후보키 중 선택된 키, Null 불가.
4. **대체키**: 기본키로 선택되지 않은 후보키.
5. **외래키**: 다른 릴레이션의 기본키를 참조, 릴레이션 간 관계 표현.
---
## 무결성 제약 (Integrity Constraint)
### 개체 무결성
- 기본키는 Null 값을 가질 수 없음.
- 투플 식별을 위해 중복 불가.
### 참조 무결성
- 외래키는 참조 가능한 값만 가질 수 있음.
- 외래키 속성은 Null 값을 가질 수 있음.
---
### 이상 현상
- **삽입 이상 (Insertion Anomaly)**: 불필요한 데이터를 삽입해야만 새 데이터를 추가할 수 있는 문제.
- **갱신 이상 (Update Anomaly)**: 일부 데이터만 갱신되어 데이터 불일치 문제가 발생.
- **삭제 이상 (Deletion Anomaly)**: 데이터를 삭제할 때 필요한 정보까지 손실되는 문제.
### 정규화의 목적
- 이상 현상을 제거하여 데이터베이스를 올바르게 설계.
- 데이터 중복을 최소화하고 데이터 일관성을 유지.
---
### 함수 종속 개념
- "X가 Y를 결정한다"는 의미.
- 하나의 X 값에 대해 Y 값이 항상 하나로 결정됨.
- 표기: X → Y (X는 결정자, Y는 종속자).
### 함수 종속 유형
- **완전 함수 종속 (Full Functional Dependency)**: Y가 X 전체에 종속되며, 부분 집합에는 종속되지 않음.
- **부분 함수 종속 (Partial Functional Dependency)**: Y가 X 전체가 아닌 일부에만 종속됨.
- **이행적 함수 종속 (Transitive Functional Dependency)**: X → Y, Y → Z일 때, X → Z가 성립.
---
### 정규화 개념
- 릴레이션을 분해하여 이상 현상이 발생하지 않는 구조로 변환.
- 무손실 분해를 유지해야 함.
### 정규형 (Normal Form) 정의
1. **제1 정규형 (1NF)**: 속성이 원자 값만을 가짐.
    - 예: 중첩 데이터가 없는 테이블.
2. **제2 정규형 (2NF)**: 제1 정규형을 만족하며, 모든 속성이 기본키에 완전 함수 종속.
    - 문제 해결: 부분 함수 종속 제거.
3. **제3 정규형 (3NF)**: 제2 정규형을 만족하며, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않음.
    - 문제 해결: 이행적 함수 종속 제거.
4. **보이스-코드 정규형 (BCNF)**: 모든 결정자가 후보키임.
    - 제3 정규형을 만족하지만 후보키가 아닌 결정자가 존재할 때 적용.
5. **제4 정규형 (4NF)**: BCNF를 만족하며, 다치 종속 (MVD)을 제거.
6. **제5 정규형 (5NF)**: 제4 정규형을 만족하며, 조인 종속 (JD)을 제거.
### 정규화 주의 사항
- 모든 릴레이션이 제5 정규형에 속할 필요는 없음.
- 일반적으로 제3 정규형이나 BCNF까지 정규화를 수행하여 데이터 중복과 이상 현상을 해결.